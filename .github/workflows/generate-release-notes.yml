name: Generate Release Notes with Multi-Label Support

on:
  release:
    types: [published]

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Simple YAML parser for our specific use case
            function parseReleaseConfig(content) {
              const lines = content.split('\n');
              const categories = [];
              let currentCategory = null;
              let inLabels = false;

              for (const line of lines) {
                const trimmed = line.trim();
                
                if (trimmed.startsWith('- title:')) {
                  if (currentCategory) categories.push(currentCategory);
                  currentCategory = { 
                    title: trimmed.replace('- title:', '').trim().replace(/^["']|["']$/g, ''),
                    labels: []
                  };
                  inLabels = false;
                } else if (currentCategory && trimmed === 'labels:') {
                  inLabels = true;
                } else if (inLabels && trimmed.startsWith('- ')) {
                  const label = trimmed.substring(2).trim().replace(/^["']|["']$/g, '');
                  if (label && label !== 'labels:') {
                    currentCategory.labels.push(label);
                  }
                } else if (inLabels && !trimmed.startsWith('-') && trimmed) {
                  inLabels = false;
                }
              }
              
              if (currentCategory) categories.push(currentCategory);
              return { changelog: { categories, exclude: { labels: ['ignore-for-release'] } } };
            }

            // Load release.yml configuration
            const configContent = fs.readFileSync('.github/release.yml', 'utf8');
            const releaseConfig = parseReleaseConfig(configContent);
            
            // Get the current release
            const release = context.payload.release;

            // Get previous release for date comparison
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const previousRelease = releases.data.find((r, i) => i > 0);
            const currentReleaseDate = release.published_at.split('T')[0];
            const previousReleaseDate = previousRelease?.published_at.split('T')[0];

            // Build query to get merged PRs between releases
            let query = `repo:${context.repo.owner}/${context.repo.repo} is:merged`;
            if (previousReleaseDate && currentReleaseDate) {
              query += ` merged:${previousReleaseDate}..${currentReleaseDate}`;
            }

            console.log('Search query:', query);

            const searchResult = await github.rest.search.issuesAndPullRequests({
              q: query,
              sort: 'created',
              order: 'desc',
              per_page: 100,
            });

            console.log('Search result:', JSON.stringify(searchResult.data, null, 2));

            const prs = (searchResult.data?.items || []).filter(item => item.pull_request);

            console.log(`Found ${prs.length} merged pull requests`);

            // If no PRs found, add a note
            if (prs.length === 0) {
              console.log('No pull requests found for this release');
              const noChangesNote = '## Changes\n\nNo pull requests were merged in this release.';
              
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: context.payload.release.id,
                body: noChangesNote,
              });
              
              return;
            }

            // Build categorized notes
            const categories = releaseConfig.changelog.categories;
            const excludeLabels = releaseConfig.changelog.exclude.labels || [];
            
            const categorizedPRs = {};
            
            // Initialize categories
            categories.forEach(cat => {
              categorizedPRs[cat.title] = [];
            });

            // Process each PR
            prs.forEach(pr => {
              const prLabels = pr.labels.map(l => l.name);
              
              // Skip if in exclude list
              if (prLabels.some(l => excludeLabels.includes(l))) {
                return;
              }

              // Find all matching categories for this PR
              const matchingCategories = [];
              categories.forEach(cat => {
                const hasMatchingLabel = cat.labels.some(catLabel =>
                  prLabels.includes(catLabel)
                );
                if (hasMatchingLabel) {
                  matchingCategories.push(cat.title);
                }
              });

              // If no matching categories, add to "Other Changes" if it exists
              if (matchingCategories.length === 0) {
                const otherCat = categories.find(c => c.labels.includes('maintenance'));
                if (otherCat) {
                  matchingCategories.push(otherCat.title);
                }
              }

              // Add PR to all matching categories
              matchingCategories.forEach(catTitle => {
                categorizedPRs[catTitle].push({
                  number: pr.number,
                  title: pr.title,
                  user: pr.user.login,
                  url: pr.html_url,
                  labels: prLabels,
                });
              });
            });

            // Build release notes content
            let releaseNotes = '';
            categories.forEach(cat => {
              const prsInCategory = categorizedPRs[cat.title];
              if (prsInCategory && prsInCategory.length > 0) {
                releaseNotes += `## ${cat.title}\n\n`;
                
                prsInCategory.forEach(pr => {
                  releaseNotes += `- [#${pr.number}](${pr.url}): ${pr.title} (@${pr.user})\n`;
                });
                
                releaseNotes += '\n';
              }
            });

            // Update release body
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: releaseNotes.trim(),
            });

            console.log('Release notes generated successfully!');
            console.log(releaseNotes);
