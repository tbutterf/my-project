name: Generate Release Notes with Multi-Label Support

on:
  release:
    types: [published]

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Simple YAML parser for our specific use case
            function parseReleaseConfig(content) {
              const lines = content.split('\n');
              const categories = [];
              let currentCategory = null;
              let inLabels = false;

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Skip empty lines and comments
                if (!trimmed || trimmed.startsWith('#')) {
                  continue;
                }
                
                if (trimmed.startsWith('- title:')) {
                  if (currentCategory && currentCategory.labels.length > 0) {
                    categories.push(currentCategory);
                  } else if (currentCategory) {
                    console.warn(`Category "${currentCategory.title}" has no labels defined`);
                    categories.push(currentCategory);
                  }
                  
                  const titleMatch = trimmed.match(/- title:\s*['"]?([^'"]+)['"]?/);
                  if (!titleMatch) {
                    throw new Error(`Invalid title format on line ${i + 1}: ${trimmed}`);
                  }
                  
                  currentCategory = { 
                    title: titleMatch[1].trim(),
                    labels: []
                  };
                  inLabels = false;
                } else if (currentCategory && trimmed === 'labels:') {
                  inLabels = true;
                } else if (inLabels && trimmed.startsWith('- ')) {
                  const labelMatch = trimmed.match(/- ['"]?([^'"]+)['"]?/);
                  if (labelMatch) {
                    const label = labelMatch[1].trim();
                    if (label && label !== 'labels:') {
                      currentCategory.labels.push(label);
                    }
                  }
                } else if (inLabels && !trimmed.startsWith('-') && trimmed && !trimmed.startsWith('#')) {
                  inLabels = false;
                }
              }
              
              // Push the last category if it has labels
              if (currentCategory && currentCategory.labels.length > 0) {
                categories.push(currentCategory);
              } else if (currentCategory) {
                console.warn(`Category "${currentCategory.title}" has no labels defined`);
                categories.push(currentCategory);
              }
              
              if (categories.length === 0) {
                throw new Error('No valid categories found in release.yml');
              }
              
              return { changelog: { categories, exclude: { labels: ['ignore-for-release'] } } };
            }

            // Load release.yml configuration with error handling
            let releaseConfig;
            try {
              if (!fs.existsSync('.github/release.yml')) {
                throw new Error('.github/release.yml file not found');
              }
              const configContent = fs.readFileSync('.github/release.yml', 'utf8');
              releaseConfig = parseReleaseConfig(configContent);
              
              if (!releaseConfig.changelog || !releaseConfig.changelog.categories || releaseConfig.changelog.categories.length === 0) {
                throw new Error('Invalid release.yml format: no categories found');
              }
            } catch (error) {
              console.error('Failed to load release configuration:', error.message);
              throw error;
            }
            
            // Get the current release
            const release = context.payload.release;
            const currentTag = release.tag_name;

            // Get previous release by comparing tags
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            // Filter out the current release and get the first (most recent) previous release
            const previousRelease = releases.data.filter(r => r.id !== release.id)[0];
            const previousTag = previousRelease?.tag_name;
            
            if (!previousRelease) {
              console.log('No previous release found. This is the first release.');
            }

            // Use the compare commits API to get the actual commits between releases
            let allPRs = [];
            
            if (previousTag && currentTag) {
              try {
                // Get the commit SHAs for both tags
                const currentTagRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${currentTag}`,
                });
                
                const previousTagRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${previousTag}`,
                });
                
                const currentSha = currentTagRef.data.object.sha;
                const previousSha = previousTagRef.data.object.sha;
                
                console.log(`Comparing commits: ${previousTag} (${previousSha}) -> ${currentTag} (${currentSha})`);
                
                // Get commits between the two SHAs
                const compareResult = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: previousSha,
                  head: currentSha,
                });
                
                const commits = compareResult.data.commits || [];
                console.log(`Found ${commits.length} commits between tags`);
                
                // Get all PRs and filter to only those merged between these commits
                let page = 1;
                let hasMore = true;
                const prMap = new Map(); // Use map to deduplicate by PR number
                
                while (hasMore && page <= 10) {
                  const prsResult = await github.rest.pulls.list({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'closed',
                    sort: 'updated',
                    direction: 'desc',
                    per_page: 100,
                    page: page,
                  });
                  
                  const prs = prsResult.data || [];
                  
                  for (const pr of prs) {
                    // Only include merged PRs
                    if (!pr.merged_at) {
                      continue;
                    }
                    
                    // Check if this PR's merge commit is in the range between previousSha and currentSha
                    if (pr.merge_commit_sha) {
                      // Check if merge commit is in the commits between the two refs
                      const isInRange = commits.some(c => c.sha === pr.merge_commit_sha);
                      
                      if (isInRange && !prMap.has(pr.number)) {
                        prMap.set(pr.number, pr);
                        console.log(`Found PR #${pr.number} in commit range`);
                      }
                    }
                  }
                  
                  // Stop if we got less than 100 results or haven't found new PRs
                  hasMore = prs.length === 100;
                  page++;
                }
                
                allPRs = Array.from(prMap.values());
                console.log(`Total PRs found in commit range: ${allPRs.length}`);
                
              } catch (error) {
                console.error('Failed to compare commits:', error.message);
                // Fallback to search-based approach if comparison fails
                console.log('Falling back to search-based approach...');
              }
            }
            
            // If we don't have PRs yet (either no previous release or compare failed), use search
            if (allPRs.length === 0) {
              console.log('Using search-based approach to find PRs...');
              let query = `repo:${context.repo.owner}/${context.repo.repo} is:merged`;
              
              if (previousTag && currentTag) {
                // For tagged releases, use the tag dates as fallback
                try {
                  const currentTagRef = await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${currentTag}`,
                  });
                  
                  const previousTagRef = await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${previousTag}`,
                  });
                  
                  const currentCommit = await github.rest.git.getCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    commit_sha: currentTagRef.data.object.sha,
                  });
                  
                  const previousCommit = await github.rest.git.getCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    commit_sha: previousTagRef.data.object.sha,
                  });
                  
                  const currentDate = currentCommit.data.committer.date.split('T')[0];
                  const previousDate = previousCommit.data.committer.date.split('T')[0];
                  
                  query += ` merged:${previousDate}..${currentDate}`;
                  console.log(`Using commit dates: ${previousDate} to ${currentDate}`);
                } catch (error) {
                  console.warn('Failed to get tag dates, using release dates as fallback');
                  const currentDate = release.published_at.split('T')[0];
                  const previousDate = previousRelease?.published_at.split('T')[0];
                  if (previousDate && currentDate) {
                    query += ` merged:${previousDate}..${currentDate}`;
                  }
                }
              }

              console.log('Search query:', query);

              // Pagination handling to retrieve all results
              // Note: GitHub Search API has a hard limit of 1000 results total
              let searchPRs = [];
              let page = 1;
              let hasMore = true;
              const MAX_RESULTS = 1000;
              const MAX_PAGES = 10; // 10 pages * 100 per page = 1000

              while (hasMore && searchPRs.length < MAX_RESULTS && page <= MAX_PAGES) {
                const searchResult = await github.rest.search.issuesAndPullRequests({
                  q: query,
                  sort: 'created',
                  order: 'desc',
                  per_page: 100,
                  page: page,
                });

                const items = searchResult.data?.items || [];
                searchPRs = searchPRs.concat(items);
                
                console.log(`Page ${page}: Retrieved ${items.length} items. Total so far: ${searchPRs.length}`);
                
                // Stop if we got less than per_page (no more results) or reached the limit
                hasMore = items.length === 100 && searchPRs.length < MAX_RESULTS;
                page++;
              }

              if (searchPRs.length >= MAX_RESULTS) {
                console.warn(`Search results reached GitHub API limit of ${MAX_RESULTS} items. Some PRs may be excluded.`);
              }

              console.log(`Search completed. Total items found: ${searchPRs.length}`);
              
              // Convert search results to PR objects and add to allPRs
              const searchResultPRs = searchPRs.filter(item => item.pull_request);
              allPRs = allPRs.concat(searchResultPRs);
            }

            console.log(`Search completed. Total items found: ${allPRs.length}`);


            console.log(`Total PRs found: ${allPRs.length}`);

            // If no PRs found, add a note
            if (allPRs.length === 0) {
              console.log('No pull requests found for this release');
              const noChangesNote = '## Changes\n\nNo pull requests were merged in this release.';
              
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: context.payload.release.id,
                body: noChangesNote,
              });
              
              return;
            }

            // Build categorized notes
            const categories = releaseConfig.changelog.categories;
            const excludeLabels = releaseConfig.changelog.exclude.labels || [];
            
            const categorizedPRs = {};
            
            // Initialize categories
            categories.forEach(cat => {
              categorizedPRs[cat.title] = [];
            });

            // Process each PR
            allPRs.forEach(pr => {
              const prLabels = pr.labels.map(l => l.name);
              
              // Skip if in exclude list
              if (prLabels.some(l => excludeLabels.includes(l))) {
                return;
              }

              // Find all matching categories for this PR
              const matchingCategories = [];
              categories.forEach(cat => {
                const hasMatchingLabel = cat.labels.some(catLabel =>
                  prLabels.includes(catLabel)
                );
                if (hasMatchingLabel) {
                  matchingCategories.push(cat.title);
                }
              });

              // If no matching categories, add to "Other Changes" if it exists
              if (matchingCategories.length === 0) {
                const otherCat = categories.find(c => c.title.toLowerCase() === 'other changes');
                if (otherCat) {
                  matchingCategories.push(otherCat.title);
                }
              }

              // Add PR to all matching categories
              matchingCategories.forEach(catTitle => {
                categorizedPRs[catTitle].push({
                  number: pr.number,
                  title: pr.title,
                  user: pr.user.login,
                  url: pr.html_url,
                  labels: prLabels,
                });
              });
            });

            // Build release notes content
            let releaseNotes = `## What's Changed\n\n`;
            categories.forEach(cat => {
              const prsInCategory = categorizedPRs[cat.title];
              if (prsInCategory && prsInCategory.length > 0) {
                releaseNotes += `### ${cat.title}\n\n`;
                
                prsInCategory.forEach(pr => {
                  releaseNotes += `- ${pr.title} by @${pr.user} in [#${pr.number}](${pr.url})\n`;
                });
                
                releaseNotes += '\n';
              }
            });

            // Update release body
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: releaseNotes.trim(),
            });

            console.log('Release notes generated successfully!');
            console.log(releaseNotes);
