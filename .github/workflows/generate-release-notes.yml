name: Generate Release Notes with Multi-Label Support

on:
  release:
    types: [published]

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Simple YAML parser for our specific use case
            function parseReleaseConfig(content) {
              const lines = content.split('\n');
              const categories = [];
              let currentCategory = null;
              let inLabels = false;

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Skip empty lines and comments
                if (!trimmed || trimmed.startsWith('#')) {
                  continue;
                }
                
                if (trimmed.startsWith('- title:')) {
                  if (currentCategory && currentCategory.labels.length > 0) {
                    categories.push(currentCategory);
                  } else if (currentCategory) {
                    console.warn(`Category "${currentCategory.title}" has no labels defined`);
                    categories.push(currentCategory);
                  }
                  
                  const titleMatch = trimmed.match(/- title:\s*['"]?([^'"]+)['"]?/);
                  if (!titleMatch) {
                    throw new Error(`Invalid title format on line ${i + 1}: ${trimmed}`);
                  }
                  
                  currentCategory = { 
                    title: titleMatch[1].trim(),
                    labels: []
                  };
                  inLabels = false;
                } else if (currentCategory && trimmed === 'labels:') {
                  inLabels = true;
                } else if (inLabels && trimmed.startsWith('- ')) {
                  const labelMatch = trimmed.match(/- ['"]?([^'"]+)['"]?/);
                  if (labelMatch) {
                    const label = labelMatch[1].trim();
                    if (label && label !== 'labels:') {
                      currentCategory.labels.push(label);
                    }
                  }
                } else if (inLabels && !trimmed.startsWith('-') && trimmed && !trimmed.startsWith('#')) {
                  inLabels = false;
                }
              }
              
              // Push the last category if it has labels
              if (currentCategory && currentCategory.labels.length > 0) {
                categories.push(currentCategory);
              } else if (currentCategory) {
                console.warn(`Category "${currentCategory.title}" has no labels defined`);
                categories.push(currentCategory);
              }
              
              if (categories.length === 0) {
                throw new Error('No valid categories found in release.yml');
              }
              
              return { changelog: { categories, exclude: { labels: ['ignore-for-release'] } } };
            }

            // Load release.yml configuration with error handling
            let releaseConfig;
            try {
              if (!fs.existsSync('.github/release.yml')) {
                throw new Error('.github/release.yml file not found');
              }
              const configContent = fs.readFileSync('.github/release.yml', 'utf8');
              releaseConfig = parseReleaseConfig(configContent);
              
              if (!releaseConfig.changelog || !releaseConfig.changelog.categories || releaseConfig.changelog.categories.length === 0) {
                throw new Error('Invalid release.yml format: no categories found');
              }
            } catch (error) {
              console.error('Failed to load release configuration:', error.message);
              throw error;
            }
            
            // Get the current release
            const release = context.payload.release;

            // Get previous release for date comparison
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            // Filter out the current release and get the first (most recent) previous release
            const previousRelease = releases.data.filter(r => r.id !== release.id)[0];
            const currentReleaseDate = release.published_at.split('T')[0];
            const previousReleaseDate = previousRelease?.published_at.split('T')[0];
            
            if (!previousRelease) {
              console.log('No previous release found. This is the first release.');
            }

            // Build query to get merged PRs between releases
            let query = `repo:${context.repo.owner}/${context.repo.repo} is:merged`;
            if (previousReleaseDate && currentReleaseDate) {
              query += ` merged:${previousReleaseDate}..${currentReleaseDate}`;
            }

            console.log('Search query:', query);

            // Pagination handling to retrieve all results
            // Note: GitHub Search API has a hard limit of 1000 results total
            let allPRs = [];
            let page = 1;
            let hasMore = true;
            const MAX_RESULTS = 1000;
            const MAX_PAGES = 10; // 10 pages * 100 per page = 1000

            while (hasMore && allPRs.length < MAX_RESULTS && page <= MAX_PAGES) {
              const searchResult = await github.rest.search.issuesAndPullRequests({
                q: query,
                sort: 'created',
                order: 'desc',
                per_page: 100,
                page: page,
              });

              const items = searchResult.data?.items || [];
              allPRs = allPRs.concat(items);
              
              console.log(`Page ${page}: Retrieved ${items.length} items. Total so far: ${allPRs.length}`);
              
              // Stop if we got less than per_page (no more results) or reached the limit
              hasMore = items.length === 100 && allPRs.length < MAX_RESULTS;
              page++;
            }

            if (allPRs.length >= MAX_RESULTS) {
              console.warn(`Search results reached GitHub API limit of ${MAX_RESULTS} items. Some PRs may be excluded.`);
            }

            console.log(`Search completed. Total items found: ${allPRs.length}`);

            const prs = allPRs.filter(item => item.pull_request);

            console.log(`Found ${prs.length} merged pull requests`);

            // If no PRs found, add a note
            if (prs.length === 0) {
              console.log('No pull requests found for this release');
              const noChangesNote = '## Changes\n\nNo pull requests were merged in this release.';
              
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: context.payload.release.id,
                body: noChangesNote,
              });
              
              return;
            }

            // Build categorized notes
            const categories = releaseConfig.changelog.categories;
            const excludeLabels = releaseConfig.changelog.exclude.labels || [];
            
            const categorizedPRs = {};
            
            // Initialize categories
            categories.forEach(cat => {
              categorizedPRs[cat.title] = [];
            });

            // Process each PR
            prs.forEach(pr => {
              const prLabels = pr.labels.map(l => l.name);
              
              // Skip if in exclude list
              if (prLabels.some(l => excludeLabels.includes(l))) {
                return;
              }

              // Find all matching categories for this PR
              const matchingCategories = [];
              categories.forEach(cat => {
                const hasMatchingLabel = cat.labels.some(catLabel =>
                  prLabels.includes(catLabel)
                );
                if (hasMatchingLabel) {
                  matchingCategories.push(cat.title);
                }
              });

              // If no matching categories, add to "Other Changes" if it exists
              if (matchingCategories.length === 0) {
                const otherCat = categories.find(c => c.title.toLowerCase() === 'other changes');
                if (otherCat) {
                  matchingCategories.push(otherCat.title);
                }
              }

              // Add PR to all matching categories
              matchingCategories.forEach(catTitle => {
                categorizedPRs[catTitle].push({
                  number: pr.number,
                  title: pr.title,
                  user: pr.user.login,
                  url: pr.html_url,
                  labels: prLabels,
                });
              });
            });

            // Build release notes content
            let releaseNotes = '';
            categories.forEach(cat => {
              const prsInCategory = categorizedPRs[cat.title];
              if (prsInCategory && prsInCategory.length > 0) {
                releaseNotes += `## ${cat.title}\n\n`;
                
                prsInCategory.forEach(pr => {
                  releaseNotes += `- [#${pr.number}](${pr.url}): ${pr.title} (@${pr.user})\n`;
                });
                
                releaseNotes += '\n';
              }
            });

            // Update release body
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: releaseNotes.trim(),
            });

            console.log('Release notes generated successfully!');
            console.log(releaseNotes);
